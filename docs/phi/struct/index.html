<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>phi.struct API documentation</title>
<meta name="description" content="*Deprecated* â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>phi.struct</code></h1>
</header>
<section id="section-intro">
<p><em>Deprecated</em>.</p>
<p>Simplifies working with nested structures of lists, tuples, dicts and objects.</p>
<p>Main functions:</p>
<ul>
<li>map</li>
<li>foreach</li>
<li>flatten</li>
<li>zip</li>
<li>names</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
*Deprecated*.

Simplifies working with nested structures of lists, tuples, dicts and objects.

Main functions:

* map
* foreach
* flatten
* zip
* names

&#34;&#34;&#34;

from ._context import unsafe
from ._trait import Trait
from ._structdef import definition, variable, constant, derived
from ._item_condition import DATA, VARIABLES, CONSTANTS, ALL_ITEMS, ignore
from ._struct import Struct, kwargs, to_dict, variables, constants, properties_dict, copy_with, isstruct, equal, VALID, INVALID

# pylint: disable-msg = redefined-builtin
from ._struct_functions import flatten, unflatten, names, map, map_item, foreach, zip, Trace, compare, print_differences, shape, staticshape, dtype, any, all


__all__ = [key for key in globals().keys() if not key.startswith(&#39;_&#39;)]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="phi.struct.all"><code class="name flex">
<span>def <span class="ident">all</span></span>(<span>condition_struct)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all(condition_struct):
    values = flatten(condition_struct)
    for value in values:
        if not value:
            return False
    return True</code></pre>
</details>
</dd>
<dt id="phi.struct.any"><code class="name flex">
<span>def <span class="ident">any</span></span>(<span>condition_struct)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def any(condition_struct):
    values = flatten(condition_struct)
    for value in values:
        if value:
            return True
    return False</code></pre>
</details>
</dd>
<dt id="phi.struct.compare"><code class="name flex">
<span>def <span class="ident">compare</span></span>(<span>structs, leaf_condition=None, recursive=True, item_condition=ALL)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare(structs, leaf_condition=None, recursive=True, item_condition=ALL_ITEMS):
    if len(structs) &lt;= 1:
        return []
    result = set()

    def check(trace):
        value = trace.value
        for other in structs[1:]:
            try:
                other_value = trace.find_in(other)
                if not equal(value, other_value):
                    result.add(trace)
            except (ValueError, KeyError, TypeError):
                result.add(trace)
    map(check, structs[0], leaf_condition=leaf_condition, recursive=recursive, trace=True, item_condition=item_condition, content_type=INVALID)
    return result</code></pre>
</details>
</dd>
<dt id="phi.struct.constant"><code class="name flex">
<span>def <span class="ident">constant</span></span>(<span>default=None, dependencies=(), holds_data=False, **trait_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Required decorator for constants_dict of custom structs.
The enclosing class must be decorated with struct.definition().</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>default</code></strong></dt>
<dd>default value passed to validation if no other value is specified</dd>
<dt><strong><code>dependencies</code></strong></dt>
<dd>other items (string or reference for inherited constants_dict) (Default value = ())</dd>
<dt><strong><code>holds_data</code></strong></dt>
<dd>determines whether the constant is considered by data-related functions (Default value = False)</dd>
<dt><strong><code>**trait_kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>read-only property</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constant(default=None, dependencies=(), holds_data=False, **trait_kwargs):
    &#34;&#34;&#34;
    Required decorator for constants_dict of custom structs.
    The enclosing class must be decorated with struct.definition().

    Args:
      default: default value passed to validation if no other value is specified
      dependencies: other items (string or reference for inherited constants_dict) (Default value = ())
      holds_data: determines whether the constant is considered by data-related functions (Default value = False)
      **trait_kwargs: 

    Returns:
      read-only property

    &#34;&#34;&#34;
    def decorator(validate):
        return Item(validate.__name__, validate, False, default, dependencies, holds_data, **trait_kwargs)
    return decorator</code></pre>
</details>
</dd>
<dt id="phi.struct.constants"><code class="name flex">
<span>def <span class="ident">constants</span></span>(<span>struct)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constants(struct):
    if isinstance(struct, (list, tuple, dict, np.ndarray)):
        return {}
    else:
        return to_dict(struct, CONSTANTS)</code></pre>
</details>
</dd>
<dt id="phi.struct.copy_with"><code class="name flex">
<span>def <span class="ident">copy_with</span></span>(<span>struct, new_values_dict, change_type=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_with(struct, new_values_dict, change_type=None):
    if isinstance(struct, Struct):
        return struct.copied_with(change_type=change_type, **new_values_dict)
    if isinstance(struct, tuple):
        duplicate = list(struct)
        for key, value in new_values_dict.items():
            duplicate[key] = value
        return tuple(duplicate)
    if isinstance(struct, list):
        duplicate = list(struct)
        for key, value in new_values_dict.items():
            duplicate[key] = value
        return duplicate
    if isinstance(struct, np.ndarray) and struct.dtype == np.object:
        duplicate = struct.copy()
        for key, value in new_values_dict.items():
            duplicate[key] = value
        return duplicate
    if isinstance(struct, dict):
        duplicate = dict(struct)
        for key, value in new_values_dict.items():
            duplicate[key] = value
        if type(struct) is dict:
            return duplicate
        else:
            return type(struct)(duplicate)
    raise ValueError(&#34;Not a struct: %s&#34; % struct)</code></pre>
</details>
</dd>
<dt id="phi.struct.definition"><code class="name flex">
<span>def <span class="ident">definition</span></span>(<span>traits=())</span>
</code></dt>
<dd>
<div class="desc"><p>Required decorator for custom struct classes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>traits</code></strong></dt>
<dd>(Default value = ())</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def definition(traits=()):
    &#34;&#34;&#34;
    Required decorator for custom struct classes.

    Args:
      traits:  (Default value = ())

    Returns:

    &#34;&#34;&#34;
    if isinstance(traits, Trait):
        traits = (traits,)
    else:
        for trait in traits:
            assert isinstance(trait, Trait), &#39;Illegal trait: %s&#39; % trait
        traits = tuple(traits)

    def decorator(struct_class, traits=traits):
        assert struct_class.__initialized_class__ != struct_class, &#39;Struct class already initialized: %s&#39; % struct_class
        items = {}
        for attribute_name in dir(struct_class):
            item = getattr(struct_class, attribute_name)
            if isinstance(item, Item):
                items[attribute_name] = item
        # --- Inheritance ---
        inherited_traits = ()
        for base in struct_class.__bases__:
            if base.__name__ != &#39;Struct&#39; and hasattr(base, &#39;__items__&#39;):
                for item in base.__items__:
                    if item.name not in items:
                        subclassed_item = copy.copy(item)
                        items[item.name] = subclassed_item
                        setattr(struct_class, item.name, subclassed_item)
                for trait in base.__traits__:
                    if trait not in traits:
                        inherited_traits += (trait,)
        traits = inherited_traits + tuple([t for t in traits if t not in inherited_traits])
        assert len(set(traits)) == len(traits), &#34;Duplicate traits on struct class &#39;%s&#39;&#34; % struct_class
        # --- Initialize &amp; Decorate ---
        struct_class.__traits__ = traits
        for item in items.values():
            item.__initialize_for__(struct_class)
        items = _order_by_dependencies(items, struct_class)
        struct_class.__items__ = tuple(items)
        struct_class.__initialized_class__ = struct_class
        # --- Check trait keywords ---
        for item in items:
            for trait_kw, trait_kw_val in item.trait_kwargs.items():
                matching_traits = [trait for trait in traits if trait_kw in trait.keywords]
                if len(matching_traits) == 0:
                    raise ValueError(&#39;Trait keyword &#34;%s&#34; does not match any trait of struct %s&#39; % (trait_kw, struct_class.__name__))
                for trait in matching_traits:
                    trait.check_argument(struct_class, item, trait_kw, trait_kw_val)
        return struct_class
    return decorator</code></pre>
</details>
</dd>
<dt id="phi.struct.derived"><code class="name flex">
<span>def <span class="ident">derived</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Derived properties work similar to @property but can be easily broadcast across many instances.
:return: read-only property</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def derived():
    &#34;&#34;&#34;
    Derived properties work similar to @property but can be easily broadcast across many instances.
    :return: read-only property

    Args:

    Returns:

    &#34;&#34;&#34;
    def decorator(getter):
        return DerivedProperty(getter.__name__, getter)
    return decorator</code></pre>
</details>
</dd>
<dt id="phi.struct.dtype"><code class="name flex">
<span>def <span class="ident">dtype</span></span>(<span>obj, leaf_condition=None, item_condition=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Maps all values of a struct to their respective data types using <code>math.dtype()</code>.
To specify custom dtypes, add an override with key struct.dtype to the Item.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>struct or leaf</dd>
<dt><strong><code>leaf_condition</code></strong></dt>
<dd>optional) leaf_condition passed to <code><a title="phi.struct.map" href="#phi.struct.map">map()</a></code> (Default value = None)</dd>
<dt><strong><code>item_condition</code></strong></dt>
<dd>optional) item_condition passed to <code><a title="phi.struct.map" href="#phi.struct.map">map()</a></code> (Default value = None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Struct of same type holding data types instead of data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dtype(obj, leaf_condition=None, item_condition=None):
    &#34;&#34;&#34;
    Maps all values of a struct to their respective data types using `math.dtype()`.
    To specify custom dtypes, add an override with key struct.dtype to the Item.

    Args:
      obj: struct or leaf
      leaf_condition: optional) leaf_condition passed to `map` (Default value = None)
      item_condition: optional) item_condition passed to `map` (Default value = None)

    Returns:
      Struct of same type holding data types instead of data

    &#34;&#34;&#34;
    def get_dtype(obj):
        try:
            return choose_backend(obj).dtype(obj)
        except NoBackendFound:
            return type(obj)
    if isinstance(obj, Struct):
        if not skip_validate():
            assert obj.content_type is VALID or obj.content_type is INVALID, &#34;dtype can only be accessed on data structs but &#39;%s&#39; has content type &#39;%s&#39;&#34; % (type(obj).__name__, obj.content_type)
    return map(get_dtype, obj, leaf_condition=leaf_condition, item_condition=item_condition, content_type=dtype)</code></pre>
</details>
</dd>
<dt id="phi.struct.equal"><code class="name flex">
<span>def <span class="ident">equal</span></span>(<span>obj1, obj2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equal(obj1, obj2):
    if isinstance(obj1, np.ndarray) or isinstance(obj2, np.ndarray):
        if obj1.dtype != np.object and obj2.dtype != np.object:
            if not np.allclose(obj1, obj2):
                return False
        else:
            if not np.all(obj1 == obj2):
                return False
    else:
        try:
            if obj1 != obj2:
                return False
            # pylint: disable-msg = broad-except  # the exception type can depend on the values
        except (ValueError, BaseException):  # not a boolean result
            if obj1 is not obj2:
                return False
    return True</code></pre>
</details>
</dd>
<dt id="phi.struct.flatten"><code class="name flex">
<span>def <span class="ident">flatten</span></span>(<span>struct, leaf_condition=None, trace=False, item_condition=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a list of all leaves by recursively iterating over the given struct.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>struct</code></strong></dt>
<dd>struct or leaf</dd>
<dt><strong><code>leaf_condition</code></strong></dt>
<dd>optional) function that determines which structs are treated as leaves. Non-structs are always treated as leaves. (Default value = None)</dd>
<dt><strong><code>trace</code></strong></dt>
<dd>If True, returns a list of Trace objects instead of values. (Default value = False)</dd>
<dt><strong><code>item_condition</code></strong></dt>
<dd>optional) ItemCondition or boolean function that filters which Items are accumulated. (Default value = None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list containing all leaves in the struct hierarchy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatten(struct, leaf_condition=None, trace=False, item_condition=None):
    &#34;&#34;&#34;
    Generates a list of all leaves by recursively iterating over the given struct.

    Args:
      struct: struct or leaf
      leaf_condition: optional) function that determines which structs are treated as leaves. Non-structs are always treated as leaves. (Default value = None)
      trace: If True, returns a list of Trace objects instead of values. (Default value = False)
      item_condition: optional) ItemCondition or boolean function that filters which Items are accumulated. (Default value = None)

    Returns:
      list containing all leaves in the struct hierarchy

    &#34;&#34;&#34;
    def map_leaf(value):
        result.append(value)
        return value
    result = []
    map(map_leaf, struct, leaf_condition, recursive=True, trace=trace, item_condition=item_condition, content_type=INVALID)
    return result</code></pre>
</details>
</dd>
<dt id="phi.struct.foreach"><code class="name flex">
<span>def <span class="ident">foreach</span></span>(<span>function, *structs, leaf_condition=None, recursive=True, trace=False, item_condition=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def foreach(function, *structs, leaf_condition=None, recursive=True, trace=False, item_condition=None):
    if len(structs) == 1:
        map(function, structs[0], leaf_condition, recursive, trace, item_condition, content_type=INVALID)
    else:
        struct = zip(structs, leaf_condition, item_condition)
        map(function, struct, leaf_condition, recursive, trace, item_condition, content_type=INVALID)</code></pre>
</details>
</dd>
<dt id="phi.struct.ignore"><code class="name flex">
<span>def <span class="ident">ignore</span></span>(<span>items)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ignore(items):
    if not isinstance(items, (tuple, list)):
        items = (items,)
    for ignored_item in items:
        assert isinstance(ignored_item, Item) or isinstance(ignored_item, str)

    def is_ignored(item):
        for ignored in items:
            if item is ignored:
                return True
            if item.name == ignored:
                return True
        return False

    condition = ItemCondition(lambda item: not is_ignored(item), &#39;ignore %s&#39; % items)
    return condition</code></pre>
</details>
</dd>
<dt id="phi.struct.isstruct"><code class="name flex">
<span>def <span class="ident">isstruct</span></span>(<span>obj, leaf_condition=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isstruct(obj, leaf_condition=None):
    if not isinstance(obj, (Struct, list, tuple, dict, np.ndarray)):
        return False
    if isinstance(obj, np.ndarray) and obj.dtype != np.object:
        return False
    if leaf_condition is not None and leaf_condition(obj):
        return False
    return True</code></pre>
</details>
</dd>
<dt id="phi.struct.kwargs"><code class="name flex">
<span>def <span class="ident">kwargs</span></span>(<span>locals, include_self=False, ignore=())</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kwargs(locals, include_self=False, ignore=()):
    # pylint: disable-msg = redefined-builtin
    assert &#39;kwargs&#39; in locals, &#34;No &#39;kwargs&#39; variable found in locals. Maybe you forgot to add &#39;**kwargs&#39; as a parameter.&#34;
    locals = locals.copy()
    kwargs_in_locals = locals[&#39;kwargs&#39;]
    del locals[&#39;kwargs&#39;]
    locals.update(kwargs_in_locals)
    if not include_self and &#39;self&#39; in locals:
        del locals[&#39;self&#39;]
    if isinstance(ignore, str):
        ignore = [ignore]
    for ignored_name in ignore:
        if ignored_name in locals:
            del locals[ignored_name]
    return locals</code></pre>
</details>
</dd>
<dt id="phi.struct.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>function, struct, leaf_condition=None, recursive=True, trace=False, item_condition=None, content_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Iterates over all items of the struct and maps their values according to the specified function.
Preserves the hierarchical structure of struct, returning an object of the same type and leaving struct untouched.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>function</code></strong></dt>
<dd>function mapping from leaf values to new values. If not otherwise specified, the new values will be validated before map returns. If trace=True, Trace objects will be passed instead of values. For zipped structs, multiple values or a Trace containing multiple values is passed to function.</dd>
<dt><strong><code>struct</code></strong></dt>
<dd>struct or leaf value</dd>
<dt><strong><code>leaf_condition</code></strong></dt>
<dd>optional) function that determines which structs are treated as leaves. Non-structs are always treated as leaves. Leaf structs are not iterated over but directly passed to function. (Default value = None)</dd>
<dt><strong><code>recursive</code></strong></dt>
<dd>If True, recursively iterates over all non-leaf sub-structs, passing only leaves to function. Otherwise only iterates over direct items of struct; all sub-structs are treated as leaves. (Default value = True)</dd>
<dt><strong><code>trace</code></strong></dt>
<dd>If True, passes a Trace object to function instead of the value. Traces contain additional information. (Default value = False)</dd>
<dt><strong><code>item_condition</code></strong></dt>
<dd>optional) ItemCondition or boolean function that filters which Items are iterated over. Excluded items are left untouched. If None, the context item condition is used (data-holding items by default).</dd>
<dt><strong><code>content_type</code></strong></dt>
<dd>optional) Type key to use for new Structs. Defaults to VALID. Item-specific overrides can be defined by calling Item.override using the content_type as key. Override functions must have the signature (parent_struct, value).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>object of the same type and hierarchy as struct</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(function, struct, leaf_condition=None, recursive=True, trace=False, item_condition=None, content_type=None):
    &#34;&#34;&#34;
    Iterates over all items of the struct and maps their values according to the specified function.
    Preserves the hierarchical structure of struct, returning an object of the same type and leaving struct untouched.

    Args:
      function: function mapping from leaf values to new values. If not otherwise specified, the new values will be validated before map returns. If trace=True, Trace objects will be passed instead of values. For zipped structs, multiple values or a Trace containing multiple values is passed to function.
      struct: struct or leaf value
      leaf_condition: optional) function that determines which structs are treated as leaves. Non-structs are always treated as leaves. Leaf structs are not iterated over but directly passed to function. (Default value = None)
      recursive: If True, recursively iterates over all non-leaf sub-structs, passing only leaves to function. Otherwise only iterates over direct items of struct; all sub-structs are treated as leaves. (Default value = True)
      trace: If True, passes a Trace object to function instead of the value. Traces contain additional information. (Default value = False)
      item_condition: optional) ItemCondition or boolean function that filters which Items are iterated over. Excluded items are left untouched. If None, the context item condition is used (data-holding items by default).
      content_type: optional) Type key to use for new Structs. Defaults to VALID. Item-specific overrides can be defined by calling Item.override using the content_type as key. Override functions must have the signature (parent_struct, value).

    Returns:
      object of the same type and hierarchy as struct

    &#34;&#34;&#34;
    # pylint: disable-msg = redefined-builtin
    if trace is True:
        trace = Trace(struct, None, None)
    if item_condition is None:
        item_condition = context_item_condition
    if content_type is None:
        content_type = VALID
    if not isstruct(struct, leaf_condition):
        if trace is False:
            if isinstance(struct, LeafZip):
                return function(*struct.values)
            else:
                return function(struct)
        else:
            return function(trace)
    else:
        new_values = {}
        if not recursive:
            def leaf_condition(_): return True
        for item in items(struct):
            if item_condition(item):
                old_value = item.get(struct)
                if content_type is not VALID and content_type is not INVALID and item.has_override(content_type):
                    new_value = item.get_override(content_type)(struct, old_value)
                else:
                    new_value = map(function, old_value, leaf_condition, recursive,
                                    Trace(old_value, item.name, trace) if trace is not False else False,
                                    item_condition,
                                    content_type)
                new_values[item.name] = new_value
        return copy_with(struct, new_values, change_type=content_type)</code></pre>
</details>
</dd>
<dt id="phi.struct.map_item"><code class="name flex">
<span>def <span class="ident">map_item</span></span>(<span>item, function, struct, leaf_condition=None, recursive=True, content_type=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_item(item, function, struct, leaf_condition=None, recursive=True, content_type=None):
    assert isinstance(item, Item) or isinstance(item, str)

    def item_condition(item_):
        if isinstance(item, str):
            return item_.name == item
        else:
            return item_.name == item.name
    return map(function, struct, leaf_condition=leaf_condition, recursive=recursive, trace=False, item_condition=item_condition, content_type=content_type)</code></pre>
</details>
</dd>
<dt id="phi.struct.names"><code class="name flex">
<span>def <span class="ident">names</span></span>(<span>struct, leaf_condition=None, full_path=True, basename=None, separator='.')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def names(struct, leaf_condition=None, full_path=True, basename=None, separator=&#39;.&#39;):
    def to_name(trace):
        if not full_path:
            return trace.name if basename is None else basename + separator + trace.name
        else:
            return trace.path(separator) if basename is None else basename + separator + trace.path(separator)
    return map(to_name, struct, leaf_condition, recursive=True, trace=True, content_type=names)</code></pre>
</details>
</dd>
<dt id="phi.struct.print_differences"><code class="name flex">
<span>def <span class="ident">print_differences</span></span>(<span>struct1, struct2, level=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_differences(struct1, struct2, level=0):
    if level == 0:
        print(&#39;Comparing %s with %s&#39; % (struct1, struct2))
    indent = &#39;  &#39; * level
    if not isstruct(struct1) or not isstruct(struct2):
        if not equal(struct1, struct2):
            print(indent + &#39;Values not equal: &#34;%s&#34; and &#34;%s&#34;.&#39; % (struct1, struct2))
        return
    items1 = to_dict(struct1)
    items2 = to_dict(struct2)
    tested_keys = []
    for key1 in items1.keys():
        if key1 not in items2:
            print(indent + &#39;Item &#34;%s&#34; is missing from %s.&#39; % (key1, struct2))
        else:
            if not equal(items1[key1], items2[key1]):
                print(&#39;Item &#34;%s&#34; differs between %s and %s.&#39; % (key1, struct1, struct2))
            print_differences(items1[key1], items2[key1], level + 1)
        tested_keys.append(key1)
    for key2 in items2.keys():
        if key2 not in tested_keys:
            print(indent + &#39;Item &#34;%s&#34; is missing from %s.&#39; % (key2, struct1))</code></pre>
</details>
</dd>
<dt id="phi.struct.properties_dict"><code class="name flex">
<span>def <span class="ident">properties_dict</span></span>(<span>struct)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def properties_dict(struct):
    if isinstance(struct, Struct):
        return struct.__properties_dict__()
    if isinstance(struct, (list, tuple)):
        return [properties_dict(s) for s in struct]
    if isinstance(struct, np.ndarray) and struct.dtype == np.object:
        return [properties_dict(s) for s in struct]
    if isinstance(struct, dict):
        return {key: properties_dict(value) for key,value in struct.items()}
    if isinstance(struct, np.ndarray):
        struct = struct.tolist()
    try:
        json.dumps(struct)
        return struct
    except TypeError:  # not serializable
        return {&#39;type&#39;: str(struct.__class__.__name__), &#39;module&#39;: str(struct.__class__.__module__)}</code></pre>
</details>
</dd>
<dt id="phi.struct.shape"><code class="name flex">
<span>def <span class="ident">shape</span></span>(<span>obj, leaf_condition=None, item_condition=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Maps all values of a struct to their respective dynamic shapes using <code>math.shape()</code>.
To specify custom shapes, add an override with key struct.shape to the Item.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>struct or leaf</dd>
<dt><strong><code>leaf_condition</code></strong></dt>
<dd>optional) leaf_condition passed to <code><a title="phi.struct.map" href="#phi.struct.map">map()</a></code> (Default value = None)</dd>
<dt><strong><code>item_condition</code></strong></dt>
<dd>optional) item_condition passed to <code><a title="phi.struct.map" href="#phi.struct.map">map()</a></code> (Default value = None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Struct of same type holding shapes instead of data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shape(obj, leaf_condition=None, item_condition=None):
    &#34;&#34;&#34;
    Maps all values of a struct to their respective dynamic shapes using `math.shape()`.
    To specify custom shapes, add an override with key struct.shape to the Item.

    Args:
      obj: struct or leaf
      leaf_condition: optional) leaf_condition passed to `map` (Default value = None)
      item_condition: optional) item_condition passed to `map` (Default value = None)

    Returns:
      Struct of same type holding shapes instead of data

    &#34;&#34;&#34;
    def get_shape(obj):
        try:
            return choose_backend(obj).shape(obj)
        except NoBackendFound:
            return ()
    if isinstance(obj, Struct):
        if not skip_validate():
            assert obj.content_type is VALID or obj.content_type is INVALID, &#34;shape can only be accessed on data structs but &#39;%s&#39; has content type &#39;%s&#39;&#34; % (type(obj).__name__, obj.content_type)
    return map(get_shape, obj, leaf_condition=leaf_condition, item_condition=item_condition, content_type=shape)</code></pre>
</details>
</dd>
<dt id="phi.struct.staticshape"><code class="name flex">
<span>def <span class="ident">staticshape</span></span>(<span>obj, leaf_condition=None, item_condition=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Maps all values of a struct to their respective static shapes using <code>math.staticshape()</code>.
To specify custom static shapes, add an override with key struct.staticshape to the Item.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>struct or leaf</dd>
<dt><strong><code>leaf_condition</code></strong></dt>
<dd>optional) leaf_condition passed to <code><a title="phi.struct.map" href="#phi.struct.map">map()</a></code> (Default value = None)</dd>
<dt><strong><code>item_condition</code></strong></dt>
<dd>optional) item_condition passed to <code><a title="phi.struct.map" href="#phi.struct.map">map()</a></code> (Default value = None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Struct of same type holding shapes instead of data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def staticshape(obj, leaf_condition=None, item_condition=None):
    &#34;&#34;&#34;
    Maps all values of a struct to their respective static shapes using `math.staticshape()`.
    To specify custom static shapes, add an override with key struct.staticshape to the Item.

    Args:
      obj: struct or leaf
      leaf_condition: optional) leaf_condition passed to `map` (Default value = None)
      item_condition: optional) item_condition passed to `map` (Default value = None)

    Returns:
      Struct of same type holding shapes instead of data

    &#34;&#34;&#34;
    def get_staticshape(obj):
        try:
            return choose_backend(obj).staticshape(obj)
        except NoBackendFound:
            return ()
    if isinstance(obj, Struct):
        if not skip_validate():
            assert obj.content_type is VALID or obj.content_type is INVALID, &#34;staticshape can only be accessed on data structs but &#39;%s&#39; has content type &#39;%s&#39;&#34; % (type(obj).__name__, obj.content_type)
    return map(get_staticshape, obj, leaf_condition=leaf_condition, item_condition=item_condition, content_type=staticshape)</code></pre>
</details>
</dd>
<dt id="phi.struct.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>struct, item_condition=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(struct, item_condition=None):
    if item_condition is None:
        item_condition = context_item_condition
    if isinstance(struct, Struct):
        return struct.__to_dict__(item_condition)
    if isinstance(struct, (list, tuple, np.ndarray)):
        return {i: struct[i] for i in range(len(struct)) if item_condition(Item(name=i, validation_function=None, is_variable=True, default_value=None, dependencies=(), holds_data=True))}
    if isinstance(struct, dict):
        return struct
    raise ValueError(&#34;Not a struct: %s&#34; % struct)</code></pre>
</details>
</dd>
<dt id="phi.struct.unflatten"><code class="name flex">
<span>def <span class="ident">unflatten</span></span>(<span>flat, struct, leaf_condition=None, item_condition=None, content_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Undoes a <code><a title="phi.struct.flatten" href="#phi.struct.flatten">flatten()</a></code> operation, restoring the contents of a struct from a list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>flat</code></strong></dt>
<dd>list holding the flattened contents of a struct compatible with <code>struct</code></dd>
<dt><strong><code>struct</code></strong></dt>
<dd>structure to restore data to</dd>
<dt><strong><code>leaf_condition</code></strong></dt>
<dd>optional) function that determines which structs are treated as leaves. Non-structs are always treated as leaves. (Default value = None)</dd>
<dt><strong><code>item_condition</code></strong></dt>
<dd>optional) ItemCondition or boolean function that filters which Items are accumulated. (Default value = None)</dd>
<dt><strong><code>content_type</code></strong></dt>
<dd>optional) Type key to use for new Structs. Defaults to VALID. Item-specific overrides can be defined by calling Item.override using the content_type as key. Override functions must have the signature (parent_struct, value).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>struct compatible with <code>struct</code> holding the values from the <code>flat</code> list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unflatten(flat, struct, leaf_condition=None, item_condition=None, content_type=None):
    &#34;&#34;&#34;
    Undoes a `flatten` operation, restoring the contents of a struct from a list.

    Args:
      flat: list holding the flattened contents of a struct compatible with `struct`
      struct: structure to restore data to
      leaf_condition: optional) function that determines which structs are treated as leaves. Non-structs are always treated as leaves. (Default value = None)
      item_condition: optional) ItemCondition or boolean function that filters which Items are accumulated. (Default value = None)
      content_type: optional) Type key to use for new Structs. Defaults to VALID. Item-specific overrides can be defined by calling Item.override using the content_type as key. Override functions must have the signature (parent_struct, value).

    Returns:
      struct compatible with `struct` holding the values from the `flat` list

    &#34;&#34;&#34;
    flat = list(flat)
    return map(lambda _: flat.pop(0), struct, leaf_condition=leaf_condition, item_condition=item_condition, content_type=content_type)</code></pre>
</details>
</dd>
<dt id="phi.struct.unsafe"><code class="name flex">
<span>def <span class="ident">unsafe</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unsafe():
    warnings.warn(&#34;struct.unsafe() is deprecated. Use map() with new_type argument to avoid validation.&#34;)
    return _struct_context(&#39;unsafe&#39;)</code></pre>
</details>
</dd>
<dt id="phi.struct.variable"><code class="name flex">
<span>def <span class="ident">variable</span></span>(<span>default=None, dependencies=(), holds_data=True, **trait_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Required decorator for data_dict of custom structs.
The enclosing class must be decorated with struct.definition().</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>default</code></strong></dt>
<dd>default value passed to validation if no other value is specified</dd>
<dt><strong><code>dependencies</code></strong></dt>
<dd>other items (string or reference for inherited constants_dict) (Default value = ())</dd>
<dt><strong><code>holds_data</code></strong></dt>
<dd>determines whether the variable is considered by data-related functions (Default value = True)</dd>
<dt><strong><code>**trait_kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>read-only property</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def variable(default=None, dependencies=(), holds_data=True, **trait_kwargs):
    &#34;&#34;&#34;
    Required decorator for data_dict of custom structs.
    The enclosing class must be decorated with struct.definition().

    Args:
      default: default value passed to validation if no other value is specified
      dependencies: other items (string or reference for inherited constants_dict) (Default value = ())
      holds_data: determines whether the variable is considered by data-related functions (Default value = True)
      **trait_kwargs: 

    Returns:
      read-only property

    &#34;&#34;&#34;
    def decorator(validate):
        return Item(validate.__name__, validate, True, default, dependencies, holds_data, **trait_kwargs)
    return decorator</code></pre>
</details>
</dd>
<dt id="phi.struct.variables"><code class="name flex">
<span>def <span class="ident">variables</span></span>(<span>struct)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def variables(struct):
    return to_dict(struct, VARIABLES)</code></pre>
</details>
</dd>
<dt id="phi.struct.zip"><code class="name flex">
<span>def <span class="ident">zip</span></span>(<span>structs, leaf_condition=None, item_condition=None, zip_parents_if_incompatible=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds a single struct containing LeaefZip entries from a list of compatible structs.
Passing zipped structs to 'map' will call the mapping function with the all leaves at equal positions in the structure.</p>
<p>Example <code>struct.map(lambda x, y: x+y, struct.zip([{0: 'Hello'}, {0: ' World'}]))</code> returns <code>{0: 'Hello World'}</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>structs</code></strong></dt>
<dd>iterable collection of structs or leaves</dd>
<dt><strong><code>leaf_condition</code></strong></dt>
<dd>optional) function that determines which structs are treated as leaves. Non-structs are always treated as leaves. (Default value = None)</dd>
<dt><strong><code>item_condition</code></strong></dt>
<dd>optional) ItemCondition or boolean function that filters which Items are zipped. Excluded items should have the same values among all structs. (Default value = None)</dd>
<dt><strong><code>zip_parents_if_incompatible</code></strong></dt>
<dd>If True, suppresses IncompatibleStructs errors if structs with non-matching excluded items are encountered. Instead, these structs are treated as leaves and zipped. (Default value = False)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Single struct matching the structure of any of the given structs and holding LeafZip objects as leaves for non-excluded items
:raise IncompatibleStructs: If structs with non-matching excluded items are encountered and zip_parents_if_incompatible=False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip(structs, leaf_condition=None, item_condition=None, zip_parents_if_incompatible=False):
    &#34;&#34;&#34;
    Builds a single struct containing LeaefZip entries from a list of compatible structs.
    Passing zipped structs to &#39;map&#39; will call the mapping function with the all leaves at equal positions in the structure.
    
    Example `struct.map(lambda x, y: x+y, struct.zip([{0: &#39;Hello&#39;}, {0: &#39; World&#39;}]))` returns `{0: &#39;Hello World&#39;}`.

    Args:
      structs: iterable collection of structs or leaves
      leaf_condition: optional) function that determines which structs are treated as leaves. Non-structs are always treated as leaves. (Default value = None)
      item_condition: optional) ItemCondition or boolean function that filters which Items are zipped. Excluded items should have the same values among all structs. (Default value = None)
      zip_parents_if_incompatible: If True, suppresses IncompatibleStructs errors if structs with non-matching excluded items are encountered. Instead, these structs are treated as leaves and zipped. (Default value = False)

    Returns:
      Single struct matching the structure of any of the given structs and holding LeafZip objects as leaves for non-excluded items
      :raise IncompatibleStructs: If structs with non-matching excluded items are encountered and zip_parents_if_incompatible=False

    &#34;&#34;&#34;
    # pylint: disable-msg = redefined-builtin
    assert len(structs) &gt; 0
    first = structs[0]
    if isstruct(first, leaf_condition):
        for struct in structs[1:]:
            if not isstruct(struct):
                if zip_parents_if_incompatible:
                    return LeafZip(structs)
                else:
                    raise IncompatibleStructs(&#39;Cannot zip %s and %s because the latter is not a struct.&#39; % (first, struct))
            if set(to_dict(struct, item_condition=item_condition).keys()) != set(to_dict(first, item_condition=item_condition).keys()):
                if zip_parents_if_incompatible:
                    return LeafZip(structs)
                else:
                    raise IncompatibleStructs(&#39;Cannot zip %s and %s because keys vary:\n%s\n%s&#39; % (first, struct, to_dict(first, item_condition=item_condition).keys(), to_dict(struct, item_condition=item_condition).keys()))

    if not isstruct(first, leaf_condition):
        return LeafZip(structs)

    dicts = [to_dict(struct, item_condition=item_condition) for struct in structs]
    keys = dicts[0].keys()
    new_dict = {}
    for key in keys:
        values = [d[key] for d in dicts]
        values = zip(values, leaf_condition, item_condition=item_condition, zip_parents_if_incompatible=zip_parents_if_incompatible)
        new_dict[key] = values
    return copy_with(first, new_dict, change_type=zip)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="phi.struct.Struct"><code class="flex name class">
<span>class <span class="ident">Struct</span></span>
<span>(</span><span>content_type=valid, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Deprecated.</p>
<p>Base class for all custom structs.
To implement a custom struct, extend this class and add the decorator @struct.definition().</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Struct(object):
    &#34;&#34;&#34;
    Deprecated.
    
    Base class for all custom structs.
    To implement a custom struct, extend this class and add the decorator @struct.definition().

    Args:

    Returns:

    &#34;&#34;&#34;

    __items__ = None
    __traits__ = None
    __initialized_class__ = None

    def __init__(self, content_type=VALID, **kwargs):
        assert isinstance(self, Struct), &#39;Struct.__init__() called on %s. Maybe you forgot **&#39; % type(self)
        assert self.__initialized_class__ == self.__class__, &#34;Instancing %s before struct class is initialized. Maybe you forgot to decorate the class with @struct.definition()&#34; % self.__class__.__name__
        self.__content_type__ = INVALID if content_type is VALID else content_type  # VALID, INVALID, Item for property, string for custom
        for item in self.__items__:
            if item.name not in kwargs:
                kwargs[item.name] = item.default_value
        self._set_items(**kwargs)
        for trait in self.__traits__:
            trait.endow(self)
        if content_type is not INVALID:
            self.validate()

    @derived()
    def shape(self):
        &#34;&#34;&#34;
        Retrieves the dynamic shapes of items specified through the context (see :class:`phi.struct.item_condition.ItemCondition`).
        Shapes of sub-structs are obtained using `struct.shape` while shapes of non-structs are obtained using `math.shape()`.
        
        To override the shapes of items, use `Item.override` with key `struct.shape` instead of overriding this method.
        
        The result of `x.shape` is equivalent to calling `struct.shape(x)`.
        :return: Struct of same type holding shapes instead of data

        Args:

        Returns:

        &#34;&#34;&#34;
        from ._struct_functions import shape
        return shape(self)

    @derived()
    def staticshape(self):
        &#34;&#34;&#34;
        Retrieves the static shapes of items specified through the context (see :class:`phi.struct.item_condition.ItemCondition`).
        Shapes of sub-structs are obtained using `struct.staticshape` while shapes of non-structs are obtained using `math.staticshape()`.
        
        To override the static shapes of items, use `Item.override` with key `struct.staticshape` instead of overriding this method.
        
        The result of `x.staticshape` is equivalent to calling `struct.staticshape(x)`.
        :return: Struct of same type holding shapes instead of data

        Args:

        Returns:

        &#34;&#34;&#34;
        from ._struct_functions import staticshape
        return staticshape(self)

    @derived()
    def dtype(self):
        &#34;&#34;&#34;
        Retrieves the data types of items specified through the context (see :class:`phi.struct.item_condition.ItemCondition`).
        Data types of sub-structs are obtained using `struct.dtype` while types of non-structs are obtained using `math.dtype()`.
        
        To override the dtype of items, use `Item.override` with key `struct.dtype` instead of overriding this method.
        
        The result of `x.dtype` is equivalent to calling `struct.dtype(x)`.
        :return: Struct of same type holding data types instead of data

        Args:

        Returns:

        &#34;&#34;&#34;
        from ._struct_functions import dtype
        return dtype(self)

    def map(self, function, leaf_condition=None, recursive=True, trace=False, item_condition=None, content_type=None):
        &#34;&#34;&#34;
        Alias for struct.map()

        Args:
          function: 
          leaf_condition:  (Default value = None)
          recursive:  (Default value = True)
          trace:  (Default value = False)
          item_condition:  (Default value = None)
          content_type:  (Default value = None)

        Returns:

        &#34;&#34;&#34;
        from ._struct_functions import map
        return map(function, self, leaf_condition=leaf_condition, recursive=recursive, trace=trace, item_condition=item_condition, content_type=content_type)

    def map_item(self, item, function, leaf_condition=None, recursive=True, content_type=None):
        &#34;&#34;&#34;
        Alias for struct.map_item()

        Args:
          item: 
          function: 
          leaf_condition:  (Default value = None)
          recursive:  (Default value = True)
          content_type:  (Default value = None)

        Returns:

        &#34;&#34;&#34;
        from ._struct_functions import map_item
        return map_item(item, function, self, leaf_condition=leaf_condition, recursive=recursive, content_type=content_type)

    def copied_with(self, change_type=None, **kwargs):
        &#34;&#34;&#34;
        Returns a copy of this Struct with some items values changed.
        The Struct, this method is invoked on, remains unaltered.
        The returned struct will be validated unless this struct is not valid or the content_type is set to something different than VALID.

        Args:
          change_type: content type of the returned struct (Default value = None)
          kwargs: Items to change, in the form item_name=new_value.
          **kwargs: 

        Returns:
          Altered copy of this object

        &#34;&#34;&#34;
        duplicate = copy(self)
        duplicate._set_items(**kwargs)  # pylint: disable-msg = protected-access
        target_type = change_type if change_type is not None else self.__content_type__
        if target_type is VALID and not duplicate.is_valid:
            duplicate.__content_type__ = INVALID
            duplicate.validate()
        else:
            duplicate.__content_type__ = target_type
        return duplicate

    def _set_items(self, **kwargs):
        if len(kwargs) == 0:
            return
        if self.is_valid:
            self.__content_type__ = INVALID
        for name, value in kwargs.items():
            try:
                item = getattr(self.__class__, name)
            except (KeyError, TypeError):
                raise TypeError(&#39;Struct %s has no property %s&#39; % (self, name))
            item.set(self, value)

    def validate(self):
        &#34;&#34;&#34;
        Performs validation on this struct if it holds data and is invalid.
        Data-holding structs should always be valid while structs holding non-data content such as shapes or data types are not regarded as valid.
        :return: True if validation was performed, False otherwise

        Args:

        Returns:

        &#34;&#34;&#34;
        if not skip_validate() and self.__can_validate__():
            self.__validate__()
            if self.__content_type__ is INVALID:
                self.__content_type__ = VALID
            return True
        else:
            return False

    def __can_validate__(self):
        return self.__content_type__ is INVALID

    def __validate__(self):
        for trait in self.__traits__:
            trait.pre_validate_struct(self)
        for item in self.__items__:
            item.validate(self)
        for trait in self.__traits__:
            trait.post_validate_struct(self)

    @property
    def is_valid(self):
        return self.__content_type__ is VALID

    @property
    def content_type(self):
        return self.__content_type__

    def __to_dict__(self, item_condition):
        if item_condition is not None:
            return {item.name: item.get(self) for item in self.__items__ if item_condition(item)}
        else:
            return {item.name: item.get(self) for item in self.__items__}

    def __properties_dict__(self):
        result = {item.name: properties_dict(getattr(self, item.name)) for item in self.__items__ if not item.holds_data}
        for item in self.__items__:
            if isstruct(item.get(self)):
                result[item.name] = properties_dict(item.get(self))
        result[&#39;type&#39;] = str(self.__class__.__name__)
        result[&#39;module&#39;] = str(self.__class__.__module__)
        return result

    def __eq__(self, other):
        if type(self) != type(other):  # pylint: disable-msg = unidiomatic-typecheck
            return False
        for item in self.__items__:
            if not equal(item.get(self), item.get(other)):
                return False
        return True

    def __ne__(self, other):
        return not self == other

    def __hash__(self):
        hash_value = 0
        for attr in self.__to_dict__(None).values():
            try:
                hash_value += hash(attr)
            except TypeError:  # unhashable type
                pass
        return hash_value

    def __repr__(self):
        return &#34;%s[%s]&#34; % (type(self).__name__, self.content_type)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.physics._physics.State</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.struct.Struct.content_type"><code class="name">var <span class="ident">content_type</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def content_type(self):
    return self.__content_type__</code></pre>
</details>
</dd>
<dt id="phi.struct.Struct.dtype"><code class="name">var <span class="ident">dtype</span></code></dt>
<dd>
<div class="desc"><p>Retrieves the data types of items specified through the context (see :class:<code>phi.struct.item_condition.ItemCondition</code>).
Data types of sub-structs are obtained using <code>struct.dtype</code> while types of non-structs are obtained using <code>math.dtype()</code>.</p>
<p>To override the dtype of items, use <code>Item.override</code> with key <code>struct.dtype</code> instead of overriding this method.</p>
<p>The result of <code>x.dtype</code> is equivalent to calling <code>struct.dtype(x)</code>.
:return: Struct of same type holding data types instead of data</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is not None:
        return self.getter(instance)
    else:
        self.owner = owner
        return self</code></pre>
</details>
</dd>
<dt id="phi.struct.Struct.is_valid"><code class="name">var <span class="ident">is_valid</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_valid(self):
    return self.__content_type__ is VALID</code></pre>
</details>
</dd>
<dt id="phi.struct.Struct.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>Retrieves the dynamic shapes of items specified through the context (see :class:<code>phi.struct.item_condition.ItemCondition</code>).
Shapes of sub-structs are obtained using <code>struct.shape</code> while shapes of non-structs are obtained using <code>math.shape()</code>.</p>
<p>To override the shapes of items, use <code>Item.override</code> with key <code>struct.shape</code> instead of overriding this method.</p>
<p>The result of <code>x.shape</code> is equivalent to calling <code>struct.shape(x)</code>.
:return: Struct of same type holding shapes instead of data</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is not None:
        return self.getter(instance)
    else:
        self.owner = owner
        return self</code></pre>
</details>
</dd>
<dt id="phi.struct.Struct.staticshape"><code class="name">var <span class="ident">staticshape</span></code></dt>
<dd>
<div class="desc"><p>Retrieves the static shapes of items specified through the context (see :class:<code>phi.struct.item_condition.ItemCondition</code>).
Shapes of sub-structs are obtained using <code>struct.staticshape</code> while shapes of non-structs are obtained using <code>math.staticshape()</code>.</p>
<p>To override the static shapes of items, use <code>Item.override</code> with key <code>struct.staticshape</code> instead of overriding this method.</p>
<p>The result of <code>x.staticshape</code> is equivalent to calling <code>struct.staticshape(x)</code>.
:return: Struct of same type holding shapes instead of data</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is not None:
        return self.getter(instance)
    else:
        self.owner = owner
        return self</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.struct.Struct.copied_with"><code class="name flex">
<span>def <span class="ident">copied_with</span></span>(<span>self, change_type=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this Struct with some items values changed.
The Struct, this method is invoked on, remains unaltered.
The returned struct will be validated unless this struct is not valid or the content_type is set to something different than VALID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>change_type</code></strong></dt>
<dd>content type of the returned struct (Default value = None)</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Items to change, in the form item_name=new_value.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Altered copy of this object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copied_with(self, change_type=None, **kwargs):
    &#34;&#34;&#34;
    Returns a copy of this Struct with some items values changed.
    The Struct, this method is invoked on, remains unaltered.
    The returned struct will be validated unless this struct is not valid or the content_type is set to something different than VALID.

    Args:
      change_type: content type of the returned struct (Default value = None)
      kwargs: Items to change, in the form item_name=new_value.
      **kwargs: 

    Returns:
      Altered copy of this object

    &#34;&#34;&#34;
    duplicate = copy(self)
    duplicate._set_items(**kwargs)  # pylint: disable-msg = protected-access
    target_type = change_type if change_type is not None else self.__content_type__
    if target_type is VALID and not duplicate.is_valid:
        duplicate.__content_type__ = INVALID
        duplicate.validate()
    else:
        duplicate.__content_type__ = target_type
    return duplicate</code></pre>
</details>
</dd>
<dt id="phi.struct.Struct.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, function, leaf_condition=None, recursive=True, trace=False, item_condition=None, content_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for struct.map()</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>function</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>leaf_condition</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>recursive</code></strong></dt>
<dd>(Default value = True)</dd>
<dt><strong><code>trace</code></strong></dt>
<dd>(Default value = False)</dd>
<dt><strong><code>item_condition</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>content_type</code></strong></dt>
<dd>(Default value = None)</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, function, leaf_condition=None, recursive=True, trace=False, item_condition=None, content_type=None):
    &#34;&#34;&#34;
    Alias for struct.map()

    Args:
      function: 
      leaf_condition:  (Default value = None)
      recursive:  (Default value = True)
      trace:  (Default value = False)
      item_condition:  (Default value = None)
      content_type:  (Default value = None)

    Returns:

    &#34;&#34;&#34;
    from ._struct_functions import map
    return map(function, self, leaf_condition=leaf_condition, recursive=recursive, trace=trace, item_condition=item_condition, content_type=content_type)</code></pre>
</details>
</dd>
<dt id="phi.struct.Struct.map_item"><code class="name flex">
<span>def <span class="ident">map_item</span></span>(<span>self, item, function, leaf_condition=None, recursive=True, content_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for struct.map_item()</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>function</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>leaf_condition</code></strong></dt>
<dd>(Default value = None)</dd>
<dt><strong><code>recursive</code></strong></dt>
<dd>(Default value = True)</dd>
<dt><strong><code>content_type</code></strong></dt>
<dd>(Default value = None)</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_item(self, item, function, leaf_condition=None, recursive=True, content_type=None):
    &#34;&#34;&#34;
    Alias for struct.map_item()

    Args:
      item: 
      function: 
      leaf_condition:  (Default value = None)
      recursive:  (Default value = True)
      content_type:  (Default value = None)

    Returns:

    &#34;&#34;&#34;
    from ._struct_functions import map_item
    return map_item(item, function, self, leaf_condition=leaf_condition, recursive=recursive, content_type=content_type)</code></pre>
</details>
</dd>
<dt id="phi.struct.Struct.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs validation on this struct if it holds data and is invalid.
Data-holding structs should always be valid while structs holding non-data content such as shapes or data types are not regarded as valid.
:return: True if validation was performed, False otherwise</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self):
    &#34;&#34;&#34;
    Performs validation on this struct if it holds data and is invalid.
    Data-holding structs should always be valid while structs holding non-data content such as shapes or data types are not regarded as valid.
    :return: True if validation was performed, False otherwise

    Args:

    Returns:

    &#34;&#34;&#34;
    if not skip_validate() and self.__can_validate__():
        self.__validate__()
        if self.__content_type__ is INVALID:
            self.__content_type__ = VALID
        return True
    else:
        return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.struct.Trace"><code class="flex name class">
<span>class <span class="ident">Trace</span></span>
<span>(</span><span>value, key, parent_trace)</span>
</code></dt>
<dd>
<div class="desc"><p>Used in struct.map if trace=True.
Trace objects can be used to reference a specific item of a struct or sub-struct as well as gather information about it.</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Trace(object):
    &#34;&#34;&#34;
    Used in struct.map if trace=True.
    Trace objects can be used to reference a specific item of a struct or sub-struct as well as gather information about it.

    Args:

    Returns:

    &#34;&#34;&#34;

    def __init__(self, value, key, parent_trace):
        self.value = value
        self.key = key
        self.parent = parent_trace

    @property
    def name(self):
        if self.key is None:
            return None
        if isinstance(self.key, str):
            return self.key
        else:
            return str(self.key)

    def path(self, separator=&#39;.&#39;):
        if self.parent is not None and self.parent.key is not None:
            return self.parent.path(separator) + separator + self.name
        else:
            return self.name if self.name is not None else &#39;&#39;

    def __repr__(self):
        return &#34;%s = %s&#34; % (self.path(), self.value)

    def find_in(self, base_struct):
        if self.parent is not None and self.parent.key is not None:
            base_struct = self.parent.find_in(base_struct)
        attrs = to_dict(base_struct, item_condition=ALL_ITEMS)
        return attrs[self.key]</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="phi.struct.Trace.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    if self.key is None:
        return None
    if isinstance(self.key, str):
        return self.key
    else:
        return str(self.key)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.struct.Trace.find_in"><code class="name flex">
<span>def <span class="ident">find_in</span></span>(<span>self, base_struct)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_in(self, base_struct):
    if self.parent is not None and self.parent.key is not None:
        base_struct = self.parent.find_in(base_struct)
    attrs = to_dict(base_struct, item_condition=ALL_ITEMS)
    return attrs[self.key]</code></pre>
</details>
</dd>
<dt id="phi.struct.Trace.path"><code class="name flex">
<span>def <span class="ident">path</span></span>(<span>self, separator='.')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def path(self, separator=&#39;.&#39;):
    if self.parent is not None and self.parent.key is not None:
        return self.parent.path(separator) + separator + self.name
    else:
        return self.name if self.name is not None else &#39;&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.struct.Trait"><code class="flex name class">
<span>class <span class="ident">Trait</span></span>
<span>(</span><span>keywords=())</span>
</code></dt>
<dd>
<div class="desc"><p>Traits are always handled in the order in which they were declared.
Inherited traits come before newly declared structs, unless explicitly re-declared.</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Trait(object):
    &#34;&#34;&#34;
    Traits are always handled in the order in which they were declared.
    Inherited traits come before newly declared structs, unless explicitly re-declared.

    Args:

    Returns:

    &#34;&#34;&#34;

    def __init__(self, keywords=()):
        self.keywords = keywords
        for keyword in keywords:
            assert isinstance(keyword, str)

    def check_argument(self, struct_class, item, keyword, value):
        &#34;&#34;&#34;
        Called when a keyword of the trait is used on an item.

        Args:
          struct_class: struct class
          item: Item (usually created via @variable or @constant)
          keyword: keyword present on item and part of the trait (string)
          value: value associated with the keyword for the given item

        Returns:

        &#34;&#34;&#34;
        pass

    def endow(self, struct):
        &#34;&#34;&#34;
        Called on newly created Structs with this trait.
        This method is called before the first validation.

        Args:
          struct: struct instance to be endowed with the trait

        Returns:

        &#34;&#34;&#34;
        pass

    def pre_validate_struct(self, struct):
        &#34;&#34;&#34;
        Called before a struct instance with the trait is validated.

        Args:
          struct: struct about to be validated

        Returns:

        &#34;&#34;&#34;
        pass

    def post_validate_struct(self, struct):
        &#34;&#34;&#34;
        Called after a struct instance with the trait is validated.

        Args:
          struct: validated struct

        Returns:

        &#34;&#34;&#34;
        pass

    def pre_validated(self, struct, item, value):
        &#34;&#34;&#34;
        Processes the value of an item before the validation function is called.

        Args:
          struct: struct undergoing validation
          item: item being validated
          value: item value before validation

        Returns:
          processed item value which will be passed to the validation function

        &#34;&#34;&#34;
        return value

    def post_validated(self, struct, item, value):
        &#34;&#34;&#34;
        Processes the value of an item after the validation function is called.

        Args:
          struct: struct undergoing validation
          item: item being validated
          value: item value after validation

        Returns:
          processed item value which will be stored in the struct

        &#34;&#34;&#34;
        return value

    def __eq__(self, other):
        return self.__class__ == other.__class__ if isinstance(other, Trait) else False

    def __ne__(self, other):
        return not self == other

    def __repr__(self):
        return &#39;%s (Trait)&#39; % self.__class__.__name__

    def __hash__(self):
        return hash(self.__class__)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="phi.struct.Trait.check_argument"><code class="name flex">
<span>def <span class="ident">check_argument</span></span>(<span>self, struct_class, item, keyword, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when a keyword of the trait is used on an item.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>struct_class</code></strong></dt>
<dd>struct class</dd>
<dt><strong><code>item</code></strong></dt>
<dd>Item (usually created via @variable or @constant)</dd>
<dt><strong><code>keyword</code></strong></dt>
<dd>keyword present on item and part of the trait (string)</dd>
<dt><strong><code>value</code></strong></dt>
<dd>value associated with the keyword for the given item</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_argument(self, struct_class, item, keyword, value):
    &#34;&#34;&#34;
    Called when a keyword of the trait is used on an item.

    Args:
      struct_class: struct class
      item: Item (usually created via @variable or @constant)
      keyword: keyword present on item and part of the trait (string)
      value: value associated with the keyword for the given item

    Returns:

    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="phi.struct.Trait.endow"><code class="name flex">
<span>def <span class="ident">endow</span></span>(<span>self, struct)</span>
</code></dt>
<dd>
<div class="desc"><p>Called on newly created Structs with this trait.
This method is called before the first validation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>struct</code></strong></dt>
<dd>struct instance to be endowed with the trait</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def endow(self, struct):
    &#34;&#34;&#34;
    Called on newly created Structs with this trait.
    This method is called before the first validation.

    Args:
      struct: struct instance to be endowed with the trait

    Returns:

    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="phi.struct.Trait.post_validate_struct"><code class="name flex">
<span>def <span class="ident">post_validate_struct</span></span>(<span>self, struct)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after a struct instance with the trait is validated.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>struct</code></strong></dt>
<dd>validated struct</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_validate_struct(self, struct):
    &#34;&#34;&#34;
    Called after a struct instance with the trait is validated.

    Args:
      struct: validated struct

    Returns:

    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="phi.struct.Trait.post_validated"><code class="name flex">
<span>def <span class="ident">post_validated</span></span>(<span>self, struct, item, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Processes the value of an item after the validation function is called.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>struct</code></strong></dt>
<dd>struct undergoing validation</dd>
<dt><strong><code>item</code></strong></dt>
<dd>item being validated</dd>
<dt><strong><code>value</code></strong></dt>
<dd>item value after validation</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>processed item value which will be stored in the struct</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_validated(self, struct, item, value):
    &#34;&#34;&#34;
    Processes the value of an item after the validation function is called.

    Args:
      struct: struct undergoing validation
      item: item being validated
      value: item value after validation

    Returns:
      processed item value which will be stored in the struct

    &#34;&#34;&#34;
    return value</code></pre>
</details>
</dd>
<dt id="phi.struct.Trait.pre_validate_struct"><code class="name flex">
<span>def <span class="ident">pre_validate_struct</span></span>(<span>self, struct)</span>
</code></dt>
<dd>
<div class="desc"><p>Called before a struct instance with the trait is validated.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>struct</code></strong></dt>
<dd>struct about to be validated</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pre_validate_struct(self, struct):
    &#34;&#34;&#34;
    Called before a struct instance with the trait is validated.

    Args:
      struct: struct about to be validated

    Returns:

    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="phi.struct.Trait.pre_validated"><code class="name flex">
<span>def <span class="ident">pre_validated</span></span>(<span>self, struct, item, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Processes the value of an item before the validation function is called.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>struct</code></strong></dt>
<dd>struct undergoing validation</dd>
<dt><strong><code>item</code></strong></dt>
<dd>item being validated</dd>
<dt><strong><code>value</code></strong></dt>
<dd>item value before validation</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>processed item value which will be passed to the validation function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pre_validated(self, struct, item, value):
    &#34;&#34;&#34;
    Processes the value of an item before the validation function is called.

    Args:
      struct: struct undergoing validation
      item: item being validated
      value: item value before validation

    Returns:
      processed item value which will be passed to the validation function

    &#34;&#34;&#34;
    return value</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="phi" href="../index.html">phi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="phi.struct.all" href="#phi.struct.all">all</a></code></li>
<li><code><a title="phi.struct.any" href="#phi.struct.any">any</a></code></li>
<li><code><a title="phi.struct.compare" href="#phi.struct.compare">compare</a></code></li>
<li><code><a title="phi.struct.constant" href="#phi.struct.constant">constant</a></code></li>
<li><code><a title="phi.struct.constants" href="#phi.struct.constants">constants</a></code></li>
<li><code><a title="phi.struct.copy_with" href="#phi.struct.copy_with">copy_with</a></code></li>
<li><code><a title="phi.struct.definition" href="#phi.struct.definition">definition</a></code></li>
<li><code><a title="phi.struct.derived" href="#phi.struct.derived">derived</a></code></li>
<li><code><a title="phi.struct.dtype" href="#phi.struct.dtype">dtype</a></code></li>
<li><code><a title="phi.struct.equal" href="#phi.struct.equal">equal</a></code></li>
<li><code><a title="phi.struct.flatten" href="#phi.struct.flatten">flatten</a></code></li>
<li><code><a title="phi.struct.foreach" href="#phi.struct.foreach">foreach</a></code></li>
<li><code><a title="phi.struct.ignore" href="#phi.struct.ignore">ignore</a></code></li>
<li><code><a title="phi.struct.isstruct" href="#phi.struct.isstruct">isstruct</a></code></li>
<li><code><a title="phi.struct.kwargs" href="#phi.struct.kwargs">kwargs</a></code></li>
<li><code><a title="phi.struct.map" href="#phi.struct.map">map</a></code></li>
<li><code><a title="phi.struct.map_item" href="#phi.struct.map_item">map_item</a></code></li>
<li><code><a title="phi.struct.names" href="#phi.struct.names">names</a></code></li>
<li><code><a title="phi.struct.print_differences" href="#phi.struct.print_differences">print_differences</a></code></li>
<li><code><a title="phi.struct.properties_dict" href="#phi.struct.properties_dict">properties_dict</a></code></li>
<li><code><a title="phi.struct.shape" href="#phi.struct.shape">shape</a></code></li>
<li><code><a title="phi.struct.staticshape" href="#phi.struct.staticshape">staticshape</a></code></li>
<li><code><a title="phi.struct.to_dict" href="#phi.struct.to_dict">to_dict</a></code></li>
<li><code><a title="phi.struct.unflatten" href="#phi.struct.unflatten">unflatten</a></code></li>
<li><code><a title="phi.struct.unsafe" href="#phi.struct.unsafe">unsafe</a></code></li>
<li><code><a title="phi.struct.variable" href="#phi.struct.variable">variable</a></code></li>
<li><code><a title="phi.struct.variables" href="#phi.struct.variables">variables</a></code></li>
<li><code><a title="phi.struct.zip" href="#phi.struct.zip">zip</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="phi.struct.Struct" href="#phi.struct.Struct">Struct</a></code></h4>
<ul class="two-column">
<li><code><a title="phi.struct.Struct.content_type" href="#phi.struct.Struct.content_type">content_type</a></code></li>
<li><code><a title="phi.struct.Struct.copied_with" href="#phi.struct.Struct.copied_with">copied_with</a></code></li>
<li><code><a title="phi.struct.Struct.dtype" href="#phi.struct.Struct.dtype">dtype</a></code></li>
<li><code><a title="phi.struct.Struct.is_valid" href="#phi.struct.Struct.is_valid">is_valid</a></code></li>
<li><code><a title="phi.struct.Struct.map" href="#phi.struct.Struct.map">map</a></code></li>
<li><code><a title="phi.struct.Struct.map_item" href="#phi.struct.Struct.map_item">map_item</a></code></li>
<li><code><a title="phi.struct.Struct.shape" href="#phi.struct.Struct.shape">shape</a></code></li>
<li><code><a title="phi.struct.Struct.staticshape" href="#phi.struct.Struct.staticshape">staticshape</a></code></li>
<li><code><a title="phi.struct.Struct.validate" href="#phi.struct.Struct.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.struct.Trace" href="#phi.struct.Trace">Trace</a></code></h4>
<ul class="">
<li><code><a title="phi.struct.Trace.find_in" href="#phi.struct.Trace.find_in">find_in</a></code></li>
<li><code><a title="phi.struct.Trace.name" href="#phi.struct.Trace.name">name</a></code></li>
<li><code><a title="phi.struct.Trace.path" href="#phi.struct.Trace.path">path</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.struct.Trait" href="#phi.struct.Trait">Trait</a></code></h4>
<ul class="">
<li><code><a title="phi.struct.Trait.check_argument" href="#phi.struct.Trait.check_argument">check_argument</a></code></li>
<li><code><a title="phi.struct.Trait.endow" href="#phi.struct.Trait.endow">endow</a></code></li>
<li><code><a title="phi.struct.Trait.post_validate_struct" href="#phi.struct.Trait.post_validate_struct">post_validate_struct</a></code></li>
<li><code><a title="phi.struct.Trait.post_validated" href="#phi.struct.Trait.post_validated">post_validated</a></code></li>
<li><code><a title="phi.struct.Trait.pre_validate_struct" href="#phi.struct.Trait.pre_validate_struct">pre_validate_struct</a></code></li>
<li><code><a title="phi.struct.Trait.pre_validated" href="#phi.struct.Trait.pre_validated">pre_validated</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>